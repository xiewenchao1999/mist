/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MistPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/FrostedGlassEffect.ts
var FrostedGlassEffect = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.isEnabled = true;
    this.blurStrength = plugin.settings.blurStrength;
    this.clearAreas = [];
    this.cursorPathAreas = [];
    this.isAnimating = false;
    this.lastCursorPos = null;
    this.init();
  }
  init() {
    this.setupDOM();
    this.setupEventListeners();
    this.startAnimation();
  }
  setupDOM() {
    this.container = document.body;
    this.overlay = document.createElement("div");
    this.overlay.className = "mist-overlay";
    this.overlay.style.position = "fixed";
    this.overlay.style.top = "0";
    this.overlay.style.left = "0";
    this.overlay.style.width = "100%";
    this.overlay.style.height = "100%";
    this.overlay.style.pointerEvents = "none";
    this.overlay.style.zIndex = "100";
    this.overlay.style.backdropFilter = `blur(${this.blurStrength}px)`;
    this.overlay.style.backgroundColor = "rgba(255, 255, 255, 0.3)";
    this.overlay.style.maskImage = 'url(data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="black"/></svg>)';
    this.overlay.style.maskSize = "cover";
    this.overlay.style.maskPosition = "center";
    this.overlay.style.maskRepeat = "no-repeat";
    this.overlay.style.transition = "mask-image 0.3s ease";
    this.canvas = document.createElement("canvas");
    this.canvas.id = "mist-mask-canvas";
    this.canvas.style.position = "fixed";
    this.canvas.style.top = "0";
    this.canvas.style.left = "0";
    this.canvas.style.width = "100%";
    this.canvas.style.height = "100%";
    this.canvas.style.pointerEvents = "none";
    this.canvas.style.opacity = "0";
    this.canvas.style.zIndex = "101";
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.ctx = this.canvas.getContext("2d");
    document.body.appendChild(this.overlay);
    document.body.appendChild(this.canvas);
  }
  setupEventListeners() {
    window.addEventListener("resize", () => this.resizeCanvas());
    this.container.addEventListener("click", (e) => this.handleClick(e));
    this.setupInputEventListeners();
  }
  setupInputEventListeners() {
    const inputElements = document.querySelectorAll('input, textarea, [contenteditable="true"]');
    inputElements.forEach((input) => {
      input.addEventListener("focus", (e) => this.handleInputFocus(e));
      input.addEventListener("blur", (e) => this.handleInputBlur(e));
    });
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            if (node instanceof HTMLElement) {
              const inputs = node.querySelectorAll('input, textarea, [contenteditable="true"]');
              inputs.forEach((input) => {
                input.addEventListener("focus", (e) => this.handleInputFocus(e));
                input.addEventListener("blur", (e) => this.handleInputBlur(e));
              });
            }
          });
        }
      });
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }
  handleClick(e) {
    if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLElement && e.target.isContentEditable) {
      return;
    }
    const x = e.clientX;
    const y = e.clientY;
    this.createClearArea(x, y);
  }
  handleInputFocus(e) {
    const target = e.target;
    const cursorPos = this.getCursorPosition(target);
    const clearArea = {
      x: cursorPos.x,
      y: cursorPos.y,
      radius: 0,
      maxRadius: 60,
      opacity: 1,
      expandingSpeed: 3,
      expanding: true,
      isInputFocus: true,
      target,
      createdTime: Date.now()
    };
    target["_clearArea"] = clearArea;
    this.clearAreas.push(clearArea);
    this.addCursorMoveListeners(target);
  }
  handleInputBlur(e) {
    const target = e.target;
    if (target["_clearArea"]) {
      target["_clearArea"].isInputFocus = false;
      target["_clearArea"].fading = true;
      target["_clearArea"].fadeSpeed = 0.02;
      delete target["_clearArea"];
    }
    this.removeCursorMoveListeners(target);
  }
  addCursorMoveListeners(element) {
    element.addEventListener("input", (e) => this.updateClearAreaPosition(e.target));
    element.addEventListener("keydown", (e) => {
      setTimeout(() => this.updateClearAreaPosition(e.target), 0);
    });
    element.addEventListener("click", (e) => this.updateClearAreaPosition(e.target));
  }
  removeCursorMoveListeners(element) {
    element.removeEventListener("input", (e) => this.updateClearAreaPosition(e.target));
    element.removeEventListener("keydown", (e) => {
      setTimeout(() => this.updateClearAreaPosition(e.target), 0);
    });
    element.removeEventListener("click", (e) => this.updateClearAreaPosition(e.target));
  }
  updateClearAreaPosition(element) {
    if (!element["_clearArea"]) return;
    const cursorPos = this.getCursorPosition(element);
    const currentX = cursorPos.x;
    const currentY = cursorPos.y;
    const clearArea = element["_clearArea"];
    clearArea.x = currentX;
    clearArea.y = currentY;
    if (this.lastCursorPos) {
      const lastX = this.lastCursorPos.x;
      const lastY = this.lastCursorPos.y;
      const distance = Math.sqrt(Math.pow(currentX - lastX, 2) + Math.pow(currentY - lastY, 2));
      if (distance > 5) {
        this.generateCursorPathAreas(lastX, lastY, currentX, currentY);
      }
    }
    this.lastCursorPos = { x: currentX, y: currentY };
  }
  generateCursorPathAreas(startX, startY, endX, endY) {
    const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
    const steps = Math.ceil(distance / 15);
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = startX + (endX - startX) * t;
      const y = startY + (endY - startY) * t;
      const pathArea = {
        x,
        y,
        radius: 0,
        maxRadius: 40,
        opacity: 1,
        expandingSpeed: 4,
        fadingSpeed: 0.015,
        expanding: true,
        fading: false,
        createdTime: Date.now(),
        life: 600
      };
      this.cursorPathAreas.push(pathArea);
    }
  }
  getCursorPosition(element) {
    let x, y;
    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element.isContentEditable) {
      const selectionStart = element.selectionStart;
      const textBeforeCursor = element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement ? element.value.substring(0, selectionStart) : "";
      const computedStyle = window.getComputedStyle(element);
      const fontSize = parseFloat(computedStyle.fontSize);
      const lineHeight = parseFloat(computedStyle.lineHeight) || fontSize;
      const tempElement = document.createElement("div");
      tempElement.style.position = "absolute";
      tempElement.style.visibility = "hidden";
      tempElement.style.whiteSpace = "pre-wrap";
      tempElement.style.font = computedStyle.font;
      tempElement.style.fontSize = computedStyle.fontSize;
      tempElement.style.lineHeight = computedStyle.lineHeight;
      tempElement.style.padding = computedStyle.padding;
      tempElement.style.border = computedStyle.border;
      tempElement.textContent = textBeforeCursor;
      document.body.appendChild(tempElement);
      const elementRect = element.getBoundingClientRect();
      const tempRect = tempElement.getBoundingClientRect();
      x = elementRect.left + tempRect.width;
      y = elementRect.top + tempRect.height - lineHeight / 2;
      document.body.removeChild(tempElement);
    } else {
      const rect = element.getBoundingClientRect();
      x = rect.left + rect.width / 2;
      y = rect.top + rect.height / 2;
    }
    return { x, y };
  }
  createClearArea(x, y) {
    const clearArea = {
      x,
      y,
      radius: 0,
      maxRadius: 120,
      opacity: 1,
      life: 2500,
      fadeSpeed: 8e-3,
      expandingSpeed: 2.5,
      expanding: true,
      createdTime: Date.now()
    };
    this.clearAreas.push(clearArea);
  }
  resizeCanvas() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.drawInitialMask();
  }
  drawInitialMask() {
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.updateMask();
  }
  drawClearAreas() {
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    const now = Date.now();
    for (let i = this.clearAreas.length - 1; i >= 0; i--) {
      this.updateAndDrawSingleArea(this.clearAreas[i], this.clearAreas, i, now);
    }
    for (let i = this.cursorPathAreas.length - 1; i >= 0; i--) {
      this.updateAndDrawSingleArea(this.cursorPathAreas[i], this.cursorPathAreas, i, now);
    }
  }
  updateAndDrawSingleArea(area, areas, index, now) {
    if (area.expanding) {
      area.radius += area.expandingSpeed;
      if (area.radius >= area.maxRadius) {
        area.radius = area.maxRadius;
        area.expanding = false;
      }
    }
    if (!area.expanding && !area.fading) {
      if (!area.isInputFocus && now - area.createdTime > area.life) {
        area.fading = true;
      }
    }
    if (area.fading) {
      area.opacity -= area.fadingSpeed || area.fadeSpeed || 8e-3;
      if (area.opacity <= 0) {
        areas.splice(index, 1);
        return;
      }
    }
    this.drawRadialGradient(area.x, area.y, area.radius, area.opacity);
  }
  drawRadialGradient(x, y, radius, opacity) {
    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
    gradient.addColorStop(0.7, `rgba(255, 255, 255, ${opacity * 0.5})`);
    gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
    this.ctx.globalCompositeOperation = "destination-out";
    this.ctx.fillStyle = gradient;
    this.ctx.beginPath();
    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.globalCompositeOperation = "source-over";
  }
  updateMask() {
    const dataURL = this.canvas.toDataURL();
    this.overlay.style.maskImage = `url(${dataURL})`;
    this.overlay.style.webkitMaskImage = `url(${dataURL})`;
  }
  animate() {
    this.drawClearAreas();
    this.updateMask();
    if (this.clearAreas.length > 0 || this.cursorPathAreas.length > 0 || this.isAnimating) {
      requestAnimationFrame(() => this.animate());
    } else {
      this.isAnimating = false;
    }
  }
  startAnimation() {
    if (!this.isAnimating) {
      this.isAnimating = true;
      this.animate();
    }
  }
  // 公共方法
  toggleEffect() {
    this.isEnabled = !this.isEnabled;
    this.overlay.style.display = this.isEnabled ? "block" : "none";
  }
  adjustBlurStrength(amount) {
    this.blurStrength = Math.max(0, Math.min(20, this.blurStrength + amount));
    this.overlay.style.backdropFilter = `blur(${this.blurStrength}px)`;
  }
  updateSettings(settings) {
    this.blurStrength = settings.blurStrength;
    this.overlay.style.backdropFilter = `blur(${this.blurStrength}px)`;
  }
  cleanup() {
    this.isAnimating = false;
    window.removeEventListener("resize", () => this.resizeCanvas());
    if (this.overlay && this.overlay.parentNode) {
      this.overlay.parentNode.removeChild(this.overlay);
    }
    if (this.canvas && this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    this.clearAreas = [];
    this.cursorPathAreas = [];
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  blurStrength: 10,
  clearAreaRadius: 120,
  pathAreaRadius: 40,
  fadeSpeed: 8e-3,
  isEnabled: true
};
var MistSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Mist - Frosted Glass Effect Settings" });
    new import_obsidian.Setting(containerEl).setName("Blur Strength").setDesc("Adjust the strength of the frosted glass blur effect").addSlider(
      (slider) => slider.setLimits(0, 20, 1).setValue(this.plugin.settings.blurStrength).onChange(async (value) => {
        this.plugin.settings.blurStrength = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Clear Area Radius").setDesc("Adjust the radius of the clear area when clicking").addSlider(
      (slider) => slider.setLimits(50, 200, 10).setValue(this.plugin.settings.clearAreaRadius).onChange(async (value) => {
        this.plugin.settings.clearAreaRadius = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Path Area Radius").setDesc("Adjust the radius of the temporary clear areas along cursor path").addSlider(
      (slider) => slider.setLimits(20, 80, 5).setValue(this.plugin.settings.pathAreaRadius).onChange(async (value) => {
        this.plugin.settings.pathAreaRadius = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Fade Speed").setDesc("Adjust how quickly clear areas fade back to blur").addSlider(
      (slider) => slider.setLimits(1e-3, 0.02, 1e-3).setValue(this.plugin.settings.fadeSpeed).onChange(async (value) => {
        this.plugin.settings.fadeSpeed = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Mist Effect").setDesc("Toggle the frosted glass effect on or off").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.isEnabled).onChange(async (value) => {
        this.plugin.settings.isEnabled = value;
        await this.plugin.saveSettings();
        if (this.plugin.frostedGlassEffect) {
          this.plugin.frostedGlassEffect.toggleEffect();
        }
      })
    );
    containerEl.createEl("div", {
      text: "Use the command palette to toggle the effect or adjust blur strength quickly.",
      cls: "setting-item-description"
    });
  }
};

// src/main.ts
var MistPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.frostedGlassEffect = new FrostedGlassEffect(this);
    this.addSettingTab(new MistSettingTab(this.app, this));
    this.addCommand({
      id: "mist-toggle-effect",
      name: "Toggle Frosted Glass Effect",
      callback: () => {
        this.frostedGlassEffect.toggleEffect();
      }
    });
    this.addCommand({
      id: "mist-adjust-blur",
      name: "Adjust Blur Strength",
      callback: () => {
        this.frostedGlassEffect.adjustBlurStrength(5);
      }
    });
    console.log("Mist Plugin loaded!");
  }
  async onunload() {
    this.frostedGlassEffect.cleanup();
    console.log("Mist Plugin unloaded!");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.frostedGlassEffect.updateSettings(this.settings);
  }
};
